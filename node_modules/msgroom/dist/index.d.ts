import TypedEmitter from "typed-emitter";
import ClientEvents, { User } from "./types/events";
import { CommandMap, CommandContext, CommandWithName, Command, WalkFunction } from "./types/types";
declare const Client_base: new () => TypedEmitter<ClientEvents>;
declare class Client extends Client_base {
    #private;
    static default: typeof Client;
    private socket?;
    printErrors: boolean;
    helpSuffix: string;
    blockSelf: boolean;
    welcomeMessage: string;
    apikey?: string;
    prefixes: Set<string>;
    mainPrefix: string;
    users: Record<string, User>;
    blockedIDs: Set<string>;
    blockedSessionIDs: Set<string>;
    commands: CommandMap;
    erroredFiles: Set<string>;
    /**
     * Creates a new msgroom client.
     * @param name The username to use.
     * @param commandPrefixes List of prefixes to be used for commands. Do note these *will be pasted directly in a regular expression*, so **make sure to escape any special characters!** Set this to an empty string to disable the command system.
     * @param options Extra options.
     * @param options.server The server to connect to.
     * @param options.printErrors Whether to print errors to the console.
     * @param options.helpSuffix A suffix to add to the output of the help command.
     * @param options.blockSelf Whether the bot should block itself. Will force welcomeMessage to be sent.
     * @param options.welcomeMessage A message to send when the bot joins.
     * @param options.mainPrefix The main prefix to use in commands (for example, the help command will use this to tell the user what prefix they should use). This shouldn't have regex in it. Set this to an empty string to disable the command system.
     * @param options.apikey You can request one from ctrlz.
     */
    constructor(name: string, commandPrefixes?: string | string[], options?: {
        server?: string;
        printErrors?: boolean;
        helpSuffix?: string;
        blockSelf?: boolean;
        welcomeMessage?: string;
        mainPrefix?: string;
        apikey?: string;
    });
    /**
     * Connect to a msgroom server.
     * @returns A promise which resolves when the connection has successfully been established.
     */
    connect(): Promise<void>;
    validateNickname(name: string): void;
    disconnect(): void;
    get server(): string;
    get name(): string;
    set name(name: string);
    get ID(): string;
    get sessionID(): string;
    sendMessage(...messages: string[]): void;
    /**
     * We currently have no idea what this could be, apart from what the type must be according to the code of the official msgroom client.
     * Only msgroom staff know the list of commands.
     * @param args The arguments to pass to the `admin-action` event.
     */
    adminAction(...args: string[]): void;
    getCommand(commandAndArguments: string[]): Promise<[CommandWithName, string[]] | undefined>;
    runCommand(command: CommandWithName, commandHandlerArguments: string[], context: CommandContext): Promise<undefined>;
    processCommands(context: CommandContext): Promise<undefined>;
    walkCommandOrMap(commandOrMap: Command | CommandMap, walkFunction: WalkFunction, fullCommand?: string[]): void;
    addCommandsFromFile(file: string | URL): Promise<void>;
    addCommandsFromDirectory(directory?: string | URL): Promise<void>;
    isBlocked(userID: string, userSessionID?: string): boolean;
    isBlocked(userIDOrObject: {
        ID?: string;
        sessionID?: string;
    }): boolean;
}
export = Client;
//# sourceMappingURL=index.d.ts.map