"use strict";
const tslib_1 = require("tslib");
const socket_io_client_1 = tslib_1.__importDefault(require("socket.io-client"));
const path_1 = require("path");
const url_1 = require("url");
const array_starts_with_1 = tslib_1.__importDefault(require("array-starts-with"));
const node_events_1 = require("node:events");
const errors_1 = require("./errors");
const transforms_1 = require("./utils/transforms");
const compilerFighting_1 = require("./utils/compilerFighting");
const helpCommand_1 = tslib_1.__importDefault(require("./helpCommand"));
class Client extends node_events_1.EventEmitter {
    static default = Client;
    socket;
    #name;
    #server;
    printErrors;
    helpSuffix;
    blockSelf;
    welcomeMessage;
    apikey;
    prefixes;
    mainPrefix;
    users = {};
    #ID;
    #sessionID;
    blockedIDs = new Set();
    blockedSessionIDs = new Set();
    commands = {};
    erroredFiles = new Set();
    /**
     * Creates a new msgroom client.
     * @param name The username to use.
     * @param commandPrefixes List of prefixes to be used for commands. Do note these *will be pasted directly in a regular expression*, so **make sure to escape any special characters!** Set this to an empty string to disable the command system.
     * @param options Extra options.
     * @param options.server The server to connect to.
     * @param options.printErrors Whether to print errors to the console.
     * @param options.helpSuffix A suffix to add to the output of the help command.
     * @param options.blockSelf Whether the bot should block itself. Will force welcomeMessage to be sent.
     * @param options.welcomeMessage A message to send when the bot joins.
     * @param options.mainPrefix The main prefix to use in commands (for example, the help command will use this to tell the user what prefix they should use). This shouldn't have regex in it. Set this to an empty string to disable the command system.
     * @param options.apikey You can request one from ctrlz.
     */
    constructor(name, commandPrefixes = [], options = {}) {
        super();
        this.validateNickname(name);
        this.#name = name;
        const commandPrefixesArray = typeof commandPrefixes == "string" ? [commandPrefixes] : commandPrefixes;
        this.mainPrefix = options.mainPrefix ?? commandPrefixesArray[0];
        this.prefixes = new Set(commandPrefixesArray);
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.#server = options.server || "wss://msgroom.windows96.net";
        this.printErrors = options.printErrors ?? false;
        this.helpSuffix = options.helpSuffix ?? "";
        this.apikey = options.apikey;
        this.blockSelf = options.blockSelf ?? true;
        if (!options.welcomeMessage && this.blockSelf)
            this.welcomeMessage = `Hi there! I'm ${name}. Send ${this.mainPrefix}help for a list of commands.`;
        else
            this.welcomeMessage = options.welcomeMessage ?? "";
        this.commands.help = (0, helpCommand_1.default)(this);
    }
    /**
     * Connect to a msgroom server.
     * @returns A promise which resolves when the connection has successfully been established.
     */
    async connect() {
        return new Promise((resolve, reject) => {
            let userID;
            this.socket = (0, socket_io_client_1.default)(this.#server);
            this.socket //! don't remove this line, you'd break the types
                //#region connecting to the server
                .on("connect", () => {
                if (!this.socket)
                    throw new errors_1.ImpossibleError();
                this.socket.emit("auth", {
                    user: this.#name,
                    apikey: this.apikey,
                });
            })
                .on("disconnect", () => {
                this.emit("disconnected");
            })
                .on("connect_error", () => {
                throw new errors_1.ConnectionError();
            })
                .on("auth-complete", authenticatedUserID => {
                if (!this.socket)
                    throw new errors_1.ImpossibleError();
                this.socket.emit("online");
                userID = authenticatedUserID;
            })
                .on("auth-error", ({ reason }) => {
                reject(new errors_1.AuthError(reason));
            })
                .on("online", users => {
                users
                    .map(transforms_1.transformUser)
                    .forEach(user => this.users[user.sessionID] = user);
                this.#ID = userID;
                resolve();
            });
            //#endregion
        }).then(() => new Promise(resolve => {
            if (!this.welcomeMessage)
                resolve();
            const sessionIDHandler = (rawMessage) => {
                const message = (0, transforms_1.transformMessage)(rawMessage, this.users);
                if (!(message.content == this.welcomeMessage && message.author.ID == this.ID))
                    return;
                this.#sessionID = message.author.sessionID;
                this.blockedSessionIDs.add(this.#sessionID);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.socket.off("message", sessionIDHandler);
                resolve();
            };
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.socket.on("message", sessionIDHandler);
            this.sendMessage(this.welcomeMessage);
        })).then(() => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.socket
                //#region main events
                .on("werror", reason => {
                this.emit("werror", reason);
            })
                .on("message", rawMessage => {
                const message = (0, transforms_1.transformMessage)(rawMessage, this.users);
                if (this.isBlocked(message.author))
                    return;
                this.emit("message", message);
                void this.processCommands({
                    message,
                    send: (...args) => void this.sendMessage(...args),
                    reply: (...args) => void this.sendMessage(`@${message.author.nickname}`, ...args),
                });
            })
                .on("sys-message", rawSysMessage => {
                const sysMessage = (0, transforms_1.transformSysMessage)(rawSysMessage);
                this.emit("sys-message", sysMessage);
                //@ts-expect-error Don't worry, it's fine. Think about it, you'll understand.
                this.emit(`sys-message-${sysMessage.type}`, sysMessage);
            })
                .on("nick-changed", rawNickChangeInfo => {
                const nickChangeInfo = (0, transforms_1.transformNickChangeInfo)(rawNickChangeInfo, this.users);
                if (this.isBlocked(nickChangeInfo.user))
                    return;
                nickChangeInfo.user.nickname = nickChangeInfo.newNickname;
                this.emit("nick-change", nickChangeInfo);
            })
                .on("user-join", rawUser => {
                const user = (0, transforms_1.transformUser)(rawUser);
                if (this.isBlocked(user))
                    return;
                this.users[user.sessionID] = user;
                this.emit("user-join", user);
            })
                .on("user-leave", userLeaveInfo => {
                const user = this.users[userLeaveInfo.session_id];
                if (this.isBlocked(user))
                    return;
                this.emit("user-leave", user);
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete this.users[userLeaveInfo.session_id];
            })
                .on("user-update", userUpdateInfo => {
                const user = this.users[userUpdateInfo.user];
                if (this.isBlocked(user))
                    return;
                switch (userUpdateInfo.type) {
                    case "tag-add":
                        if (!userUpdateInfo.tag?.trim() || !userUpdateInfo.tagLabel)
                            return;
                        if (!user.flags.includes(userUpdateInfo.tag))
                            user.flags.push(userUpdateInfo.tag);
                        this.emit("tag-add", {
                            user,
                            newTag: userUpdateInfo.tag,
                            newTagLabel: userUpdateInfo.tagLabel,
                        });
                }
            });
            //#endregion
        });
    }
    validateNickname(name) {
        if (name.length > 18)
            throw new Error("Username is longer than 18 characters.");
        if (name.length < 1)
            throw new Error("Username should be 1 character or more.");
    }
    disconnect() {
        this.socket?.disconnect();
    }
    get server() {
        return this.#server;
    }
    get name() {
        return this.#name;
    }
    set name(name) {
        if (!this.socket)
            throw new errors_1.NotConnectedError();
        this.validateNickname(name);
        this.socket.emit("change-user", name);
    }
    get ID() {
        if (!this.#ID)
            throw new errors_1.NotConnectedError();
        return this.#ID;
    }
    get sessionID() {
        if (!this.#sessionID)
            throw new errors_1.NotConnectedError();
        return this.#sessionID;
    }
    sendMessage(...messages) {
        if (!this.socket)
            throw new errors_1.NotConnectedError();
        const message = messages.join(" ");
        if (message.length > 2048) {
            if (this.printErrors)
                console.warn("A message was too long and cannot be sent, it will be printed below:\n", message);
            return void this.emit("werror", "message too long");
        }
        this.socket.emit("message", {
            type: "text",
            content: message,
        });
    }
    /**
     * We currently have no idea what this could be, apart from what the type must be according to the code of the official msgroom client.
     * Only msgroom staff know the list of commands.
     * @param args The arguments to pass to the `admin-action` event.
     */
    adminAction(...args) {
        if (!this.socket)
            throw new errors_1.NotConnectedError();
        this.socket.emit("admin-action", { args });
    }
    async getCommand(commandAndArguments) {
        return new Promise(resolve => {
            let done = false;
            function testCommand(command, fullCommand) {
                if (!(0, array_starts_with_1.default)(commandAndArguments.map(argument => argument.toLowerCase()), fullCommand.map(argument => argument.toLowerCase())))
                    return false;
                const commandArguments = commandAndArguments.slice(fullCommand.length);
                const commandWithName = {
                    ...command,
                    name: fullCommand.join(" "),
                };
                done = true;
                resolve([commandWithName, commandArguments]);
                return true;
            }
            const walkFunction = (command, fullCommand) => {
                if (done)
                    return;
                if (testCommand(command, fullCommand))
                    return;
                for (const alias of command.aliases) {
                    if (testCommand(command, alias))
                        return;
                }
            };
            const commands = [];
            this.walkCommandOrMap(this.commands, (command, fullCommand) => {
                commands.push({ command, fullCommand });
            });
            commands.sort((a, b) => b.fullCommand.length - a.fullCommand.length);
            commands.forEach(({ command, fullCommand }) => void walkFunction(command, fullCommand));
            resolve(undefined);
        });
    }
    async runCommand(command, commandHandlerArguments, context) {
        try {
            const commandResult = await command.handler(context, ...commandHandlerArguments);
            if (!commandResult)
                return;
            if (typeof commandResult == "string")
                return void context.send(commandResult);
            return void context.send(...commandResult);
        }
        catch (error) {
            context.send(`An error occurred while executing ${command.name}: *${error}*`);
            if (this.printErrors)
                console.error(`
An error occurred at ${context.message.date.toString()}.
Message: ${context.message.content}
User: ${context.message.author.nickname}
User's ID: ${context.message.author.ID}
User's session ID: ${context.message.author.sessionID}
Full error:
`, error);
        }
    }
    async processCommands(context) {
        if (!this.mainPrefix)
            return;
        const message = context.message.content;
        const regex = new RegExp(`^(${Array.from(this.prefixes).join(")|(")})`, "i"); // I checked and we should we safe from ReDoS
        if (!regex.test(message))
            return;
        const parsedArguments = message.replace(regex, "").split(" ");
        const commandAndArguments = await this.getCommand(parsedArguments);
        if (!commandAndArguments)
            return void context.send(`That command doesn't exist. Run ${this.mainPrefix}help for a list of commands.`);
        await this.runCommand(...commandAndArguments, context);
    }
    walkCommandOrMap(commandOrMap, walkFunction, fullCommand = []) {
        let commandMap;
        if (typeof commandOrMap.handler == "function") {
            const command = (0, transforms_1.normalizeCommand)(commandOrMap);
            if (fullCommand.length == 0)
                throw new Error("Please provide the name of the command!");
            walkFunction(command, fullCommand);
            commandMap = command.subcommands;
        }
        else
            commandMap = commandOrMap;
        for (const command in commandMap) {
            this.walkCommandOrMap(commandMap[command], walkFunction, fullCommand.concat(command));
        }
    }
    async addCommandsFromFile(file) {
        if (typeof file != "string")
            file = file.href;
        else if (!file.startsWith("file:") && !file.startsWith("data:"))
            file = (0, url_1.pathToFileURL)(file).href;
        let defaultFileExport;
        try {
            const fileExports = await (0, compilerFighting_1.dynamicImport)(file);
            defaultFileExport = fileExports.default;
        }
        catch (error) {
            console.error(`An error occurred while loading ${file}`, error);
            this.erroredFiles.add(file);
            return;
        }
        if (typeof defaultFileExport != "function")
            defaultFileExport = defaultFileExport?.default;
        if (!defaultFileExport) {
            console.error(new Error(`${file} doesn't have a default export. The default export should be a function taking an instance of Client as the only argument and should return (a promise which resolves to) a CommandMapEntry.

If it returns a Command (any object which has a property named "handler" that resolves to a function), it will be registered accordingly to client.commands.
Do note that if you're returning a Command directly from a function, you also need to provide a property called name to provide the name of your command.

If it returns any other object, it will be assumed to be a CommandMap and all of its properties will be assigned to client.commands using Object.assign().`));
            this.erroredFiles.add(file);
            return;
        }
        let importedCommands;
        try {
            importedCommands = await defaultFileExport(this);
        }
        catch (error) {
            console.error(`An error occurred while loading ${file}`, error);
            this.erroredFiles.add(file);
            return;
        }
        if (!importedCommands)
            return;
        if (typeof importedCommands.handler == "function") {
            const command = importedCommands;
            try {
                if (!command.name)
                    throw new Error("You must provide a name for your command!");
            }
            catch (error) {
                console.error(`${file} has an invalid commandName`, error);
                this.erroredFiles.add(file);
                return;
            }
            this.commands[command.name] = command;
            //@ts-expect-error Yeah that's why I'm deleting it.
            delete this.commands[command.name].name;
            return;
        }
        const commandMap = importedCommands;
        Object.assign(this.commands, importedCommands);
    }
    async addCommandsFromDirectory(directory) {
        if (!directory) {
            if (!require.main)
                throw new Error("You cannot leave out the directory argument in this context!");
            directory = (0, path_1.resolve)(require.main.path, "./commands");
        }
        if (typeof directory != "string")
            directory = (0, url_1.fileURLToPath)(directory);
        const files = await (0, compilerFighting_1.walkDirectory)(directory);
        const modules = files
            .filter(file => file.name.endsWith(".js"))
            .map(file => this.addCommandsFromFile(file.path));
        await Promise.all(modules);
    }
    isBlocked(userIDOrObject, userSessionID) {
        let blocked = false;
        if (typeof userIDOrObject == "string")
            blocked ||= this.blockedIDs.has(userIDOrObject);
        else if (!(typeof userIDOrObject == "undefined"))
            blocked ||= this.blockedIDs.has("" + userIDOrObject.ID)
                || this.blockedSessionIDs.has("" + userIDOrObject.sessionID);
        if (typeof userSessionID == "string")
            blocked ||= this.blockedSessionIDs.has(userSessionID);
        return blocked;
    }
}
module.exports = Client;
//# sourceMappingURL=index.js.map